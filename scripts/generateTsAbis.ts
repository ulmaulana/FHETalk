/**
 * DON'T MODIFY OR DELETE THIS SCRIPT (unless you know what you're doing)
 *
 * This script generates the file containing the contracts ABI definitions.
 * These definitions are used to derive the types needed in the custom fhevm hooks, for example.
 * 
 * This script reads from compiled contract artifacts (artifacts directory).
 * If deployments exist, it will merge deployment addresses; otherwise placeholder addresses are used.
 * This allows generating types even before contracts are deployed.
 */

import * as fs from "fs";
import * as prettier from "prettier";
// Note: This script does not need Hardhat's DeployFunction typing

const generatedContractComment = `
/**
 * This file is autogenerated by helper.
 * You should not edit it manually or your changes might be overwritten.
 */
`;

const DEPLOYMENTS_DIR = "./packages/hardhat/deployments";
const ARTIFACTS_DIR = "./packages/hardhat/artifacts";
const CONTRACTS_ARTIFACTS_DIR = "./packages/hardhat/artifacts/contracts";
const TARGET_DIRS = [
  "./packages/nextjs/contracts/"
];

function getDirectories(path: string) {
  return fs
    .readdirSync(path, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);
}

function getContractNames(path: string) {
  return fs
    .readdirSync(path, { withFileTypes: true })
    .filter(dirent => dirent.isFile() && dirent.name.endsWith(".json"))
    .map(dirent => dirent.name.split(".")[0]);
}

function getActualSourcesForContract(sources: Record<string, any>, contractName: string) {
  for (const sourcePath of Object.keys(sources)) {
    const sourceName = sourcePath.split("/").pop()?.split(".sol")[0];
    if (sourceName === contractName) {
      const contractContent = sources[sourcePath].content as string;
      const regex = /contract\s+(\w+)\s+is\s+([^{}]+)\{/;
      const match = contractContent.match(regex);

      if (match) {
        const inheritancePart = match[2];
        // Split the inherited contracts by commas to get the list of inherited contracts
        const inheritedContracts = inheritancePart.split(",").map(contract => `${contract.trim()}.sol`);

        return inheritedContracts;
      }
      return [];
    }
  }
  return [];
}

function getInheritedFunctions(sources: Record<string, any>, contractName: string) {
  const actualSources = getActualSourcesForContract(sources, contractName);
  const inheritedFunctions = {} as Record<string, any>;

  for (const sourceContractName of actualSources) {
    const sourcePath = Object.keys(sources).find(key => key.includes(`/${sourceContractName}`));
    if (sourcePath) {
      const sourceName = sourcePath?.split("/").pop()?.split(".sol")[0];
      const { abi } = JSON.parse(fs.readFileSync(`${ARTIFACTS_DIR}/${sourcePath}/${sourceName}.json`).toString());
      for (const functionAbi of abi) {
        if (functionAbi.type === "function") {
          inheritedFunctions[functionAbi.name] = sourcePath;
        }
      }
    }
  }

  return inheritedFunctions;
}

function getAllContractArtifacts() {
  if (!fs.existsSync(CONTRACTS_ARTIFACTS_DIR)) {
    throw Error("Contracts artifacts directory not found. Please compile contracts first using 'pnpm hardhat:compile'");
  }
  
  const contracts = {} as Record<string, any>;
  const contractDirectories = getDirectories(CONTRACTS_ARTIFACTS_DIR);
  
  console.log(`üìã Scanning artifacts in ${CONTRACTS_ARTIFACTS_DIR}...`);
  
  for (const contractDir of contractDirectories) {
    const contractPath = `${CONTRACTS_ARTIFACTS_DIR}/${contractDir}`;
    const contractFiles = fs.readdirSync(contractPath, { withFileTypes: true })
      .filter(dirent => dirent.isFile() && dirent.name.endsWith(".json") && !dirent.name.endsWith(".dbg.json"))
      .map(dirent => dirent.name);
    
    for (const contractFile of contractFiles) {
      const contractName = contractFile.split(".")[0];
      const artifactPath = `${contractPath}/${contractFile}`;
      
      try {
        const artifact = JSON.parse(fs.readFileSync(artifactPath).toString());
        if (artifact.abi && Array.isArray(artifact.abi) && artifact.abi.length > 0) {
          // Only include main contract files (not library or interface files)
          if (!contracts[contractName] || contractFile === `${contractName}.json`) {
            contracts[contractName] = {
              abi: artifact.abi,
              bytecode: artifact.bytecode,
              metadata: artifact.metadata
            };
            console.log(`  ‚úÖ Found ${contractName} in artifacts`);
          }
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è  Failed to read artifact: ${artifactPath}`);
      }
    }
  }
  
  console.log(`üìã Found ${Object.keys(contracts).length} contracts: ${Object.keys(contracts).join(", ")}`);
  return contracts;
}

function getContractDataFromArtifacts() {
  const artifacts = getAllContractArtifacts();
  const output = {} as Record<string, any>;
  
  // Default chain IDs to include (can be extended)
  const defaultChainIds = ["31337", "11155111"]; // hardhat, sepolia
  
  // Check if deployments exist and get chain IDs from there
  let chainIds: string[] = [];
  if (fs.existsSync(DEPLOYMENTS_DIR)) {
    const chainDirectories = getDirectories(DEPLOYMENTS_DIR);
    for (const chainName of chainDirectories) {
      try {
        const chainId = fs.readFileSync(`${DEPLOYMENTS_DIR}/${chainName}/.chainId`).toString().trim();
        if (chainId && !chainIds.includes(chainId)) {
          chainIds.push(chainId);
        }
      } catch (error) {
        // Ignore if chainId file doesn't exist
      }
    }
  }
  
  // Use deployment chain IDs if available, otherwise use defaults
  if (chainIds.length === 0) {
    chainIds = defaultChainIds;
    console.log("üìã No deployments found, using default chain IDs:", chainIds.join(", "));
  } else {
    console.log("üìã Found deployments for chain IDs:", chainIds.join(", "));
  }
  
  // Generate contract data for each chain ID
  for (const chainId of chainIds) {
    const contracts = {} as Record<string, any>;
    
    for (const [contractName, artifactData] of Object.entries(artifacts)) {
      // Try to get deployment info if it exists
      let address = "0x0000000000000000000000000000000000000000";
      let deployedOnBlock: number | undefined;
      
      if (fs.existsSync(DEPLOYMENTS_DIR)) {
        // Try to find deployment for this chain
        const chainDirectories = getDirectories(DEPLOYMENTS_DIR);
        for (const chainName of chainDirectories) {
          try {
            const deploymentChainId = fs.readFileSync(`${DEPLOYMENTS_DIR}/${chainName}/.chainId`).toString().trim();
            if (deploymentChainId === chainId) {
              const deploymentFile = `${DEPLOYMENTS_DIR}/${chainName}/${contractName}.json`;
              if (fs.existsSync(deploymentFile)) {
                const deployment = JSON.parse(fs.readFileSync(deploymentFile).toString());
                address = deployment.address || address;
                deployedOnBlock = deployment.receipt?.blockNumber;
                break;
              }
            }
          } catch (error) {
            // Ignore errors
          }
        }
      }
      
      // Get inherited functions if metadata exists
      let inheritedFunctions = {};
      if (artifactData.metadata) {
        try {
          const metadata = JSON.parse(artifactData.metadata);
          if (metadata.sources) {
            inheritedFunctions = getInheritedFunctions(metadata.sources, contractName);
          }
        } catch (error) {
          // Ignore metadata parsing errors
        }
      }
      
      contracts[contractName] = {
        address,
        abi: artifactData.abi,
        inheritedFunctions,
        deployedOnBlock
      };
    }
    
    if (Object.keys(contracts).length > 0) {
      output[chainId] = contracts;
      console.log(`üìã Generated data for chain ${chainId} with ${Object.keys(contracts).length} contracts`);
    }
  }
  
  return output;
}

/**
 * Generates TypeScript contract definition files based on compiled contract artifacts
 * This script reads from artifacts directory and optionally merges deployment addresses if available
 */
const generateTsAbis = async function () {
  const allContractsData = getContractDataFromArtifacts();

  // Get all unique contract names across all chains
  const contractNames = new Set<string>();
  for (const chainData of Object.values(allContractsData)) {
    for (const contractName of Object.keys(chainData as Record<string, any>)) {
      contractNames.add(contractName);
    }
  }

  // Generate a separate file for each contract
  for (const contractName of contractNames) {
    // Build contract data across all chains
    const contractData: Record<string, any> = {};
    for (const [chainId, chainConfig] of Object.entries(allContractsData)) {
      const contracts = chainConfig as Record<string, any>;
      if (contracts[contractName]) {
        contractData[chainId] = contracts[contractName];
      }
    }

    const fileContent = Object.entries(contractData).reduce((content, [chainId, contractConfig]) => {
      return `${content}${parseInt(chainId).toFixed(0)}:${JSON.stringify(contractConfig, null, 2)},`;
    }, "");

    const fileContentFormatted = await prettier.format(
      `${generatedContractComment}
const ${contractName} = {${fileContent}} as const;

export default ${contractName};`,
      {
        parser: "typescript",
      },
    );

    // Write to all target directories
    for (const targetDir of TARGET_DIRS) {
      if (!fs.existsSync(targetDir)) {
        fs.mkdirSync(targetDir, { recursive: true });
      }
      fs.writeFileSync(`${targetDir}${contractName}.ts`, fileContentFormatted);
      console.log(`üìù Generated ${contractName}.ts: ${targetDir}${contractName}.ts`);
    }
  }

  console.log(`\n‚úÖ Generated ${contractNames.size} contract files: ${Array.from(contractNames).join(", ")}`);
};

export default generateTsAbis;

// Execute when run via ts-node
void generateTsAbis();