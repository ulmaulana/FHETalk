"use strict";
/**
 * DON'T MODIFY OR DELETE THIS SCRIPT (unless you know what you're doing)
 *
 * This script generates the file containing the contracts Abi definitions.
 * These definitions are used to derive the types needed in the custom fhevm hooks, for example.
 * This script should run as the last deploy script.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const prettier = __importStar(require("prettier"));
// Note: This script does not need Hardhat's DeployFunction typing
const generatedContractComment = `
/**
 * This file is autogenerated by helper.
 * You should not edit it manually or your changes might be overwritten.
 */
`;
const DEPLOYMENTS_DIR = "./packages/hardhat/deployments";
const ARTIFACTS_DIR = "./packages/hardhat/artifacts";
const TARGET_DIRS = ["./packages/nextjs/contracts/"];
function getDirectories(path) {
    return fs
        .readdirSync(path, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => dirent.name);
}
function getContractNames(path) {
    return fs
        .readdirSync(path, { withFileTypes: true })
        .filter(dirent => dirent.isFile() && dirent.name.endsWith(".json"))
        .map(dirent => dirent.name.split(".")[0]);
}
function getActualSourcesForContract(sources, contractName) {
    for (const sourcePath of Object.keys(sources)) {
        const sourceName = sourcePath.split("/").pop()?.split(".sol")[0];
        if (sourceName === contractName) {
            const contractContent = sources[sourcePath].content;
            const regex = /contract\s+(\w+)\s+is\s+([^{}]+)\{/;
            const match = contractContent.match(regex);
            if (match) {
                const inheritancePart = match[2];
                // Split the inherited contracts by commas to get the list of inherited contracts
                const inheritedContracts = inheritancePart.split(",").map(contract => `${contract.trim()}.sol`);
                return inheritedContracts;
            }
            return [];
        }
    }
    return [];
}
function getInheritedFunctions(sources, contractName) {
    const actualSources = getActualSourcesForContract(sources, contractName);
    const inheritedFunctions = {};
    for (const sourceContractName of actualSources) {
        const sourcePath = Object.keys(sources).find(key => key.includes(`/${sourceContractName}`));
        if (sourcePath) {
            const sourceName = sourcePath?.split("/").pop()?.split(".sol")[0];
            const { abi } = JSON.parse(fs.readFileSync(`${ARTIFACTS_DIR}/${sourcePath}/${sourceName}.json`).toString());
            for (const functionAbi of abi) {
                if (functionAbi.type === "function") {
                    inheritedFunctions[functionAbi.name] = sourcePath;
                }
            }
        }
    }
    return inheritedFunctions;
}
function getContractDataFromDeployments() {
    if (!fs.existsSync(DEPLOYMENTS_DIR)) {
        throw Error("At least one other deployment script should exist to generate an actual contract.");
    }
    const output = {};
    const chainDirectories = getDirectories(DEPLOYMENTS_DIR);
    for (const chainName of chainDirectories) {
        let chainId;
        try {
            chainId = fs.readFileSync(`${DEPLOYMENTS_DIR}/${chainName}/.chainId`).toString();
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
        }
        catch (error) {
            console.log(`No chainId file found for ${chainName}`);
            continue;
        }
        const contracts = {};
        const contractNames = getContractNames(`${DEPLOYMENTS_DIR}/${chainName}`);
        console.log(`Found ${contractNames.length} contracts in ${chainName}: ${contractNames.join(", ")}`);
        for (const contractName of contractNames) {
            const deploymentFile = `${DEPLOYMENTS_DIR}/${chainName}/${contractName}.json`;
            if (!fs.existsSync(deploymentFile)) {
                console.warn(`‚ö†Ô∏è  Deployment file not found: ${deploymentFile}`);
                continue;
            }
            const { abi, address, metadata, receipt } = JSON.parse(fs.readFileSync(deploymentFile).toString());
            const inheritedFunctions = metadata ? getInheritedFunctions(JSON.parse(metadata).sources, contractName) : {};
            contracts[contractName] = { address, abi, inheritedFunctions, deployedOnBlock: receipt?.blockNumber };
            console.log(`  ‚úÖ Added ${contractName} at ${address}`);
        }
        output[chainId] = contracts;
    }
    return output;
}
/**
 * Generates the TypeScript contract definition file based on the json output of the contract deployment scripts
 * This script should be run last.
 */
const generateTsAbis = async function () {
    const allContractsData = getContractDataFromDeployments();
    const fileContent = Object.entries(allContractsData).reduce((content, [chainId, chainConfig]) => {
        return `${content}${parseInt(chainId).toFixed(0)}:${JSON.stringify(chainConfig, null, 2)},`;
    }, "");
    if (!fs.existsSync(TARGET_DIR)) {
        fs.mkdirSync(TARGET_DIR);
    }
    fs.writeFileSync(`${TARGET_DIR}deployedContracts.ts`, await prettier.format(`${generatedContractComment} import { GenericContractsDeclaration } from "~~/utils/helper/contract"; \n\n
 const deployedContracts = {${fileContent}} as const; \n\n export default deployedContracts satisfies GenericContractsDeclaration`, {
        parser: "typescript",
    }));
    console.log(`üìù Updated TypeScript contract definition file on ${TARGET_DIR}deployedContracts.ts`);
};
exports.default = generateTsAbis;
// Execute when run via ts-node
void generateTsAbis();
